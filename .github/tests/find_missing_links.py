import os
import re


def walk_directory(directory, exclude_dirs=None, exclude_files=None):
    exclude_dirs = exclude_dirs or []
    exclude_files = exclude_files or []

    for root, dirs, files in os.walk(directory):
        if all(exclude_dir not in root for exclude_dir in exclude_dirs):
            dirs[:] = [d for d in dirs if not d.startswith(('.', '_'))]
            for file in files:
                if file.endswith(".md") and file not in exclude_files:
                    yield os.path.join(root, file)

def preprocess_article_names(file_paths):
    return [os.path.splitext(os.path.basename(file_path))[0].replace('-', ' ') for file_path in file_paths]

def create_unlinked_word_pattern(article_names):
    return re.compile(r'\b(?:' + '|'.join(map(re.escape, article_names)) + r')\b', re.IGNORECASE)

def check_file(file_path, unlinked_word_pattern):
    suggestions = set()
    file_name = file_path.split('/')[-1]

    with open(file_path, 'r', encoding='utf-8') as f:
        f.seek(0)
        next(f)
        is_frontmatter = True
        in_html_block = False

        content = f.read()
        for line in content.splitlines():

            # Return if autogenerated
            if line.strip() == "autogenerated: true":
                return

            # Skip if frontmatter
            if is_frontmatter:
                if line.startswith('---'):
                    is_frontmatter = False
                continue
            
            # Skip HTML
            if '<' in line and '>' in line:
                in_html_block = True

            if in_html_block:
                continue

            _line = line.lower()

            # Remove existing Markdown links and Liquid tags
            _line = re.sub(r'\[(.*?)\]\([^)]*?\)|\{\{[^}]*\}\}|{%[^\n]*%}', ' ... ', _line)

            # Search for suggestions
            for match in unlinked_word_pattern.finditer(_line):
                article_name = match.group()
                suggestion_key = (article_name, file_path)
                # If it's a link to our own file, skip.
                if file_name.lower() == f'{article_name.replace(" ", "-")}.md':
                    continue
                # Skip the file if the word has already been linked
                if f'[{article_name}](/' in content or f'[{article_name}s](/' in content:
                    break
                # If we already have this suggestion, skip.
                if suggestion_key in suggestions:
                    continue
                suggestions.add(suggestion_key)

                print(f'"{article_name}" in {file_path.split("/")[-1]}')
                print(f'\t at the line: {line}')
                print(f'\t can be linked: [{article_name}](/{article_name.replace(" ", "-")}) \n')
                print(30 * '-')
                input("Press ENTER for more...") # Input is used to view each 
                print(30 * '-')



EXCLUDE_DIRS = ['events', 'vendor'] # Events can be removed as soon as it becomes autogenerated
EXCLUDE_FILES = ['README.md', 'CHANGELOG.md', 'events']
DIR = ('../..')

def main():

    article_paths = list(walk_directory(DIR, exclude_dirs=EXCLUDE_DIRS, exclude_files=EXCLUDE_FILES))
    article_names = preprocess_article_names(article_paths)
    unlinked_word_pattern = create_unlinked_word_pattern(article_names)

    for article_path in article_paths:
        check_file(article_path, unlinked_word_pattern)

if __name__ == "__main__":
    main()
